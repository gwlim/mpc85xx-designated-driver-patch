--- a/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
+++ b/target/linux/ar71xx/files/drivers/net/ethernet/atheros/ag71xx/ag71xx_main.c
@@ -187,11 +187,9 @@ static void ag71xx_ring_tx_init(struct a
 static void ag71xx_ring_rx_clean(struct ag71xx *ag)
 {
 	struct ag71xx_ring *ring = &ag->rx_ring;
-	int i;
-
 	if (!ring->buf)
 		return;
-
+	int i;
 	for (i = 0; i < ring->size; i++)
 		if (ring->buf[i].rx_buf) {
 			kfree(ring->buf[i].rx_buf);
@@ -687,6 +685,7 @@ static int ag71xx_stop(struct net_device
 static int ag71xx_fill_dma_desc(struct ag71xx_ring *ring, u32 addr, int len)
 {
 	int i;
+
 	struct ag71xx_desc *desc;
 	int ndesc = 0;
 	int split = ring->desc_split;
@@ -736,10 +735,6 @@ static netdev_tx_t ag71xx_hard_start_xmi
 					  struct net_device *dev)
 {
 	struct ag71xx *ag = netdev_priv(dev);
-	struct ag71xx_ring *ring = &ag->tx_ring;
-	struct ag71xx_desc *desc;
-	dma_addr_t dma_addr;
-	int i, n, ring_min;
 
 	if (ag71xx_has_ar8216(ag))
 		ag71xx_add_ar8216_header(ag, skb);
@@ -748,15 +743,17 @@ static netdev_tx_t ag71xx_hard_start_xmi
 //		DBG("%s: packet len is too small\n", ag->dev->name);
 		goto err_drop;
 	}
-
+	struct ag71xx_ring *ring = &ag->tx_ring;
+	struct ag71xx_desc *desc;
+	dma_addr_t dma_addr;
 	dma_addr = dma_map_single(&dev->dev, skb->data, skb->len,
 				  DMA_TO_DEVICE);
 
-	i = ring->curr % ring->size;
+	int i = ring->curr % ring->size;
 	desc = ag71xx_ring_desc(ring, i);
 
 	/* setup descriptor fields */
-	n = ag71xx_fill_dma_desc(ring, (u32) dma_addr, skb->len & ag->desc_pktlen_mask);
+	int n = ag71xx_fill_dma_desc(ring, (u32) dma_addr, skb->len & ag->desc_pktlen_mask);
 	if (n < 0)
 		goto err_drop;
 
@@ -772,7 +769,7 @@ static netdev_tx_t ag71xx_hard_start_xmi
 	/* flush descriptor */
 	wmb();
 
-	ring_min = 2;
+	int ring_min = 2;
 	if (ring->desc_split)
 	    ring_min *= AG71XX_TX_RING_DS_PER_PKT;
 
@@ -798,7 +795,6 @@ err_drop:
 static int ag71xx_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
 	struct ag71xx *ag = netdev_priv(dev);
-	int ret;
 
 	switch (cmd) {
 	case SIOCETHTOOL:
@@ -806,7 +802,7 @@ static int ag71xx_do_ioctl(struct net_de
 			break;
 
 		spin_lock_irq(&ag->lock);
-		ret = phy_ethtool_ioctl(ag->phy_dev, (void *) ifr->ifr_data);
+		int ret = phy_ethtool_ioctl(ag->phy_dev, (void *) ifr->ifr_data);
 		spin_unlock_irq(&ag->lock);
 		return ret;
 
@@ -926,11 +922,11 @@ static int ag71xx_tx_packets(struct ag71
 		sent++;
 		ring->dirty += n;
 
-		while (n > 0) {
+		do {
 			ag71xx_wr(ag, AG71XX_REG_TX_STATUS, TX_STATUS_PS);
 			n--;
-		}
-	}
+		} while (n > 0);
+	} 
 
 //	DBG("%s: %d packets sent out\n", ag->dev->name, sent);
 
@@ -958,7 +954,7 @@ static int ag71xx_rx_packets(struct ag71
 //	DBG("%s: rx packets, limit=%d, curr=%u, dirty=%u\n",
 //			dev->name, limit, ring->curr, ring->dirty);
 
-	while (done < limit) {
+	do {
 		unsigned int i = ring->curr % ring->size;
 		struct ag71xx_desc *desc = ag71xx_ring_desc(ring, i);
 		struct sk_buff *skb;
@@ -1008,7 +1004,7 @@ next:
 		done++;
 
 		ring->curr++;
-	}
+	} while (done < limit);
 
 	ag71xx_ring_rx_refill(ag);
 
@@ -1022,26 +1018,22 @@ static int ag71xx_poll(struct napi_struc
 {
 	struct ag71xx *ag = container_of(napi, struct ag71xx, napi);
 	struct ag71xx_platform_data *pdata = ag71xx_get_pdata(ag);
-	struct net_device *dev = ag->dev;
+
 	struct ag71xx_ring *rx_ring;
-	unsigned long flags;
-	u32 status;
-	int tx_done;
-	int rx_done;
 
 	pdata->ddr_flush();
-	tx_done = ag71xx_tx_packets(ag, false);
+	int tx_done = ag71xx_tx_packets(ag, false);
 
 //	DBG("%s: processing RX ring\n", dev->name);
-	rx_done = ag71xx_rx_packets(ag, limit);
+	int rx_done = ag71xx_rx_packets(ag, limit);
 
 	ag71xx_debugfs_update_napi_stats(ag, rx_done, tx_done);
 
 	rx_ring = &ag->rx_ring;
 	if (rx_ring->buf[rx_ring->dirty % rx_ring->size].rx_buf == NULL)
 		goto oom;
-
-	status = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);
+	struct net_device *dev = ag->dev;
+	u32 status = ag71xx_rr(ag, AG71XX_REG_RX_STATUS);
 	if (unlikely(status & RX_STATUS_OF)) {
 		ag71xx_wr(ag, AG71XX_REG_RX_STATUS, RX_STATUS_OF);
 		dev->stats.rx_fifo_errors++;
@@ -1063,6 +1055,7 @@ static int ag71xx_poll(struct napi_struc
 
 		napi_complete(napi);
 
+		unsigned long flags;
 		/* enable interrupts */
 		spin_lock_irqsave(&ag->lock, flags);
 		ag71xx_int_enable(ag, AG71XX_INT_POLL);
